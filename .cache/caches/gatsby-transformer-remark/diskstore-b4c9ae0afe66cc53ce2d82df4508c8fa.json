{"expireTime":9007200863408274000,"key":"transformer-remark-markdown-html-b0491431cf68e504942255c4d4ff5532-gatsby-remark-relative-imagesgatsby-remark-katexgatsby-remark-imagesgatsby-remark-responsive-iframegatsby-remark-autolink-headersgatsby-remark-prismjsgatsby-remark-copy-linked-filesgatsby-remark-smartypantsgatsby-remark-external-links-","val":"<p>I still remember those days when Mobile Devs used to argue with the Backend teams regarding the unnecessary data coming in the APIs, and the reason is we used to create the General-Purpose API Backend which could be consumed by any of the clients(Web/Mobile) untill <a href=\"https://samnewman.io/patterns/architectural/bff/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">BFF (Backend for Frontend)</a> pattern was introduced by SoundCloud in 2015. But having BFF has its own caveats like, there is a high probability that each BFF may implement similar capabilities with different teams, easily doubling (or more) the cost of development and as we segment backends for each constituent frontend, the number of deployable units increases.</p>\n<p><strong>Does that mean GraphQL is going to replace BFF ?</strong>. Well, some GraphQL literature insists that this new technology gives so much freedom to the client by allowing them to perform ad-hoc queries that you can safely have a single Backend without the drawbacks from REST-based approaches. You can take a look at this amazing <a href=\"https://philcalcado.com/2019/07/12/some_thoughts_graphql_bff.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">article</a> to get more insights of it.</p>\n<p>Well, there are tons of article which explain what GraphQL is and what are its advantages over REST ? but I would like to talk about the ones which I found really useful.</p>\n<h2 id=\"avoid-under-and-over-fetching\" style=\"position:relative;\"><a href=\"#avoid-under-and-over-fetching\" aria-label=\"avoid under and over fetching permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Avoid under and over fetching</h2>\n<p>The most powerful feature of graphql is to avoid the problem of under and over-fetching. Basically using GraphQL, we are shifiting the autonomy to the client to request the data as much as it requires <strong><em>no more, no less</em></strong>.</p>\n<p>So, in our case we were working on kind of social media application where we need to show the profile of other users including their images, and basic informations like (relationship status, abut myself etc). and we wanted it to be really blazing fast and with the traditional REST intuitive pattern, this would have required us at least two requests to two endpoints</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token constant\">GET</span> <span class=\"token operator\">/</span>api<span class=\"token operator\">/</span>users\n\n<span class=\"token constant\">GET</span> <span class=\"token operator\">/</span>api<span class=\"token operator\">/</span>users<span class=\"token operator\">/</span><span class=\"token number\">1</span><span class=\"token operator\">/</span>profile</code></pre></div>\n<p>But, with GraphQL we can call this single API and prefetch all the data required.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">query users <span class=\"token punctuation\">{</span>\n id\n name\n avatars <span class=\"token punctuation\">{</span>\n\tisProfile<span class=\"token punctuation\">,</span>\n\turl\n <span class=\"token punctuation\">}</span>\n addresses <span class=\"token punctuation\">{</span>\n\ttype<span class=\"token punctuation\">,</span>\n\taddress\n <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>So instead of multiple endpoints that return fixed data structures, a GraphQL server only exposes a single endpoint and responds with precisely the data a client requested.</p>\n<h2 id=\"no-api-versioning\" style=\"position:relative;\"><a href=\"#no-api-versioning\" aria-label=\"no api versioning permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>No API Versioning</h2>\n<p>While using REST, we version API’s when we make changes to the resources or to the structure of the resources we currently have and calling the different versions of an API often times results in weird responses. for example</p>\n<p><code class=\"language-text\">api.domain.com/v1/users\napi.domain.com/v2/users</code></p>\n<p>But, in GraphQL, it is possible to deprecate API’s on a field level. When a particular field is to be deprecated, a client receives a deprecation warning when querying the field. After a while, the deprecated field may be removed from the schema when not many clients are using it anymore. Its too easy to deprecate a field if you are using <a href=\"https://www.apollographql.com\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">apollo-server</a>.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">type userGender <span class=\"token punctuation\">{</span>\n    id<span class=\"token operator\">:</span> Int<span class=\"token operator\">!</span>\n    name<span class=\"token operator\">:</span> String<span class=\"token operator\">!</span> @<span class=\"token function\">deprecated</span><span class=\"token punctuation\">(</span>reason<span class=\"token operator\">:</span> <span class=\"token string\">\"Not Required.\"</span><span class=\"token punctuation\">)</span>\n    createdAt<span class=\"token operator\">:</span> Date<span class=\"token operator\">!</span>\n    updatedAt<span class=\"token operator\">:</span> Date<span class=\"token operator\">!</span>\n  <span class=\"token punctuation\">}</span></code></pre></div>\n<p>And in GraphQL Playground, it will show the warning</p>\n<p><img src=\"/field-deprecation.png\" alt=\"alt\">\nAs a result, instead of completely versioning the API, it is possible to gradually evolve the API over time without having to restructure the entire API schema.</p>\n<p>Also, adding new fields has no effect on any current clients because you only get the fields you request.</p>\n<h2 id=\"introspectable\" style=\"position:relative;\"><a href=\"#introspectable\" aria-label=\"introspectable permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Introspectable</h2>\n<p>For REST APIs, we need to use tools like Swagger to document the APIs but, GraphQL comes with its own inbuilt Playground, using which you can see your defined schema, It’s possible to query any GraphQL API to ask it about itself. Every compliant server has a <code class=\"language-text\">__schema</code> field which will allow you to retrieve information about the available fields and types. You can create your query, mutation, subscription etc all out there and see the results.</p>\n<h2 id=\"schema-stiching\" style=\"position:relative;\"><a href=\"#schema-stiching\" aria-label=\"schema stiching permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Schema Stiching</h2>\n<p>So, this particular feature, I haven’t got a chance to use it but this feature really embraces the Microservices Archietecture. Here, the backend would be broken down into multiple microservices with distinct functionalities. As a result, each microservice can define its own GraphQL schema.</p>\n<p>Afterward, you could use schema stitching to weave all individual schemas into one general schema which can then be accessed by each of the client applications. In the end, each microservice can have its own GraphQL endpoint whereas one GraphQL API gateway consolidates all schemas into one global schema to make it available to the client applications.</p>\n<p>You can take an in-depth look at GraphQL <a href=\"https://www.apollographql.com/blog/graphql-schema-stitching-8af23354ac37/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Schema Stitching by Sashko Stubailo</a> to get a deeper understanding of the concepts involved.</p>\n<p>So, I have only mentioned the features which I have used and explored but there are lot more remaining and I would love to pen them down here as I use them.</p>\n<h2 id=\"a-big-but\" style=\"position:relative;\"><a href=\"#a-big-but\" aria-label=\"a big but permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>A Big “But”</h2>\n<p>So, the above features which I have mentioned don’t come for free. Remember? what Uncle Ben said to Peter Parker <strong><em>With great power comes great responsibility</em></strong>. And here the onus is on the developers, to keep a keen eye on the problems mentioned below.</p>\n<h2 id=\"n1-problem\" style=\"position:relative;\"><a href=\"#n1-problem\" aria-label=\"n1 problem permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>(N+1) Problem</h2>\n<p>The one big gotcha with the GraphQL is (N+1) DB hits, So lets say we have schema like this</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">schema <span class=\"token operator\">=</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">{\n  type Query {\n    users: [User]\n  } \n  \n  type User {\n    id: Int\n    avatars: [Image] \n  } \n\n  type Image {\n    id: Int \n    isProfile: String\n\t\turl: String\n  }\n}</span><span class=\"token template-punctuation string\">`</span></span>\n\nresolvers <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  Query<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function-variable function\">users</span><span class=\"token operator\">:</span> <span class=\"token keyword\">async</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token constant\">ORM</span><span class=\"token punctuation\">.</span><span class=\"token function\">getAllUsers</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  User<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function-variable function\">avatars</span><span class=\"token operator\">:</span>  <span class=\"token keyword\">async</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">userObj<span class=\"token punctuation\">,</span> args</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token constant\">ORM</span><span class=\"token punctuation\">.</span><span class=\"token function\">getImagesFor</span><span class=\"token punctuation\">(</span>userObj<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>And the number of SQL queries would look like</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">SELECT *\nFROM authors; \nSELECT *\nFROM books \nWHERE author_id in (1); \nSELECT * \nFROM books \nWHERE author_id in (2); \nSELECT *\nFROM books \nWHERE author_id in (3); </code></pre></div>\n<p>This is where the name comes from, by the way. We will always make 1 initial query to the DB and return N results, which means we will have to make N additional DB queries. Now this is an intrinsic problem with the GraphQL and to solve this there’s a really handy tool that came out right alongside GraphQL called <a href=\"https://github.com/graphql/dataloader\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">DataLoader</a>.</p>\n<p><strong>Dataloader</strong> essentially wait for all your resolvers to load in their individual keys. Once it has them, it hits the DB once with the keys, and returns a promise that resolves an array of the values. It batches our queries instead of making one at a time. So, in above case it would just call the single IN query will all the userIds defined in it to fetch the images for them.</p>\n<p>And I have used it extensively in my current project, will have a separate blog for the same.</p>\n<h2 id=\"caching\" style=\"position:relative;\"><a href=\"#caching\" aria-label=\"caching permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Caching</h2>\n<p>The goal of caching an API response is primarily to obtain the response from future requests faster. Unlike GraphQL, caching is built into in the HTTP specification which RESTful APIs are able to leverage.</p>\n<p>With REST we access resources with the URLs, and thus we would be able to cache on a resource level because we have the resource URL as an identifier. In GraphQL, this becomes complex as each query can be different even though it operates on the same entity.</p>\n<p>For example in one query we might be interested in just the name of a User, however, in the next query you might want their addresses, images etc. This is the point where caching is mostly complex as it will require field level caching which is not an easy thing to achieve with GraphQL since it uses a single endpoint.</p>\n<p>We could use libraries like Dataloaders to achieve Caching at the Backend but, still on the client sides this would be really tricky.</p>\n<h2 id=\"freedoom-to-the-clients-could-be-dangerous\" style=\"position:relative;\"><a href=\"#freedoom-to-the-clients-could-be-dangerous\" aria-label=\"freedoom to the clients could be dangerous permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Freedoom to the Clients could be dangerous</h2>\n<p>GraphQL provides autonomy to the clients to execute queries to get exactly what they need. This is an amazing feature however, it could be a bit controversial as it could also mean that users can ask for as many fields in as many resources as they want. for example</p>\n<p>code</p>\n<p>This query could potentially get tens of thousands of data in response and could even kill your server.</p>\n<p>Therefore, as much as it is a good thing to allow users to request for whatever they need, at certain levels of complexity, requests like this can slow down performs and immensely affect the efficiency of GraphQL applications.</p>\n<p>To avoid the mentioned problem, we can configue the Maximum Query Depth using which we could prevent the clients from abusing query depth like this. Do read the amazing article to get to know about the few strategies to mitigate these types of risks.</p>\n<h2 id=\"duplication-of-schemas\" style=\"position:relative;\"><a href=\"#duplication-of-schemas\" aria-label=\"duplication of schemas permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Duplication of Schemas</h2>\n<p>When building with GraphQL on the backend, you would have some duplication and code repetition especially when it comes to schemas. First, you need a schema for your database(data models) and another for your GraphQL endpoint, this involves similar but, not quite identical code, especially when it comes to schemas.</p>\n<p>It is really difficult that you have to write very similar code for your schemas and data models, but it’s even more frustrating that you also have to continually keep them in sync.</p>\n<p>Apparently, efforts have been made in the GraphQL community to fix it. PostGraphile, Prisma, Hasura etc. these tools generates a GraphQL schema from your database schema.</p>\n<h2 id=\"conclusion\" style=\"position:relative;\"><a href=\"#conclusion\" aria-label=\"conclusion permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Conclusion</h2>\n<p>The conclusion I arrived at when writing my GraphQL server was that GraphQL is not the elixir I thought it was. Though, all the features it advertised sounded incredible.\nLearning the schema language of GraphQL was not difficult. Once you learn about schemas, resolvers, object types, query and mutation you are ready to write your GraphQL server.</p>\n<p>The only major problem I see with GraphQL is (N+1) DB hits, for which Dataloaders was introduced to resque but, coming from the REST background sometimes, I get confused while writing the GraphQL schemas say for example</p>\n<p>So, here either I can define options as a field resolver and use Dataloader or get the entire data in a single query using joins which more sounds like a REST. So, In order to decide I think of the clients who are going to use these APIs. I would not use GraphQL in a simple application (for example, one that uses a few fields in the same way, every time) as it would add more complexity. but if I would have various clients, with different data requirements, I would use GraphQL without a doubt.</p>"}