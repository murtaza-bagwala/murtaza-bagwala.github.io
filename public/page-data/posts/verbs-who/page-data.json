{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/verbs-who","result":{"data":{"markdownRemark":{"id":"b9c4a669-ea85-5bb6-9915-1d71faca8966","html":"<ul>\n<li><a href=\"#the-first-transition\">The first transition</a></li>\n<li><a href=\"#the-digital-age\">The digital age</a></li>\n<li><a href=\"#loss-of-humanity-through-transitions\">Loss of humanity through transitions</a></li>\n<li><a href=\"#chasing-perfection\">Chasing perfection</a></li>\n</ul>\n<p>In the previous posts we got to know what <code class=\"language-text\">Observable</code> is and how it is different from <code class=\"language-text\">Subject</code>.\nAlso, in previous examples we used <code class=\"language-text\">Subjects</code> and manually pushed values into them to create a <code class=\"language-text\">Observable</code> sequence to understand some key concept like most important Rx method, <strong>subscribe</strong>. In most cases, subjects are not the best way to create a new Observable. We will now see some tidier ways to create observable sequences using some simple Factory methods.</p>\n<h2 id=\"observablejust\" style=\"position:relative;\"><a href=\"#observablejust\" aria-label=\"observablejust permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Observable.just</h2>\n<p>The just method creates an Observable that will emit a predifined sequence of values, supplied on creation, and then terminate.</p>\n<p>{% highlight java %}\nObservable<String> values = Observable.just(“one”, “two”, “three”);\nSubscription subscription = values.subscribe(\nv -> System.out.println(“Received: ” + v),\ne -> System.out.println(“Error: ” + e),\n() -> System.out.println(“Completed”)\n);</p>\n<p>// Output\n// Received: one\n// Received: two\n// Received: three\n// Completed\n{% endhighlight %}</p>\n<h2 id=\"observableempty\" style=\"position:relative;\"><a href=\"#observableempty\" aria-label=\"observableempty permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Observable.empty</h2>\n<p>This observable will emit a single onCompleted and nothing else.</p>\n<p>{% highlight java %}\nObservable<String> values = Observable.empty();\nSubscription subscription = values.subscribe(\nv -> System.out.println(“Received: ” + v),\ne -> System.out.println(“Error: ” + e),\n() -> System.out.println(“Completed”)\n);</p>\n<p>// Output\n// Completed\n{% endhighlight %}</p>\n<h2 id=\"observablenever\" style=\"position:relative;\"><a href=\"#observablenever\" aria-label=\"observablenever permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Observable.never</h2>\n<p>This observable will never emit anything</p>\n<p>{% highlight java %}\nObservable<String> values = Observable.never();\nSubscription subscription = values.subscribe(\nv -> System.out.println(“Received: ” + v),\ne -> System.out.println(“Error: ” + e),\n() -> System.out.println(“Completed”)\n);\n{% endhighlight %}</p>\n<p>The code above will print nothing. Note that this doesn’t mean that the program is blocking. In fact, it will terminate immediately.</p>\n<h2 id=\"observableerror\" style=\"position:relative;\"><a href=\"#observableerror\" aria-label=\"observableerror permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Observable.error</h2>\n<p>This observable will emit a single error event and terminate.</p>\n<p>{% highlight java %}\nObservable<String> values = Observable.error(new Exception(“Oops”));\nSubscription subscription = values.subscribe(\nv -> System.out.println(“Received: ” + v),\ne -> System.out.println(“Error: ” + e),\n() -> System.out.println(“Completed”)\n);</p>\n<p>// Output\n// Error: java.lang.Exception: Oops\n{% endhighlight %}</p>\n<p>Now, you could have thought why we need these kind of Observables which do nothing so, the <code class=\"language-text\">Empty</code>, <code class=\"language-text\">Never</code>, and <code class=\"language-text\">Throw</code> operators generate Observables with very specific and limited behavior. These are useful for testing purposes, and sometimes also for combining with other Observables or as parameters to operators that expect other Observables as parameters.</p>\n<p>Now the most important and powerful function for creating Observable which gets widely used is <code class=\"language-text\">Observable.create</code>.</p>\n<h2 id=\"observablecreate\" style=\"position:relative;\"><a href=\"#observablecreate\" aria-label=\"observablecreate permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Observable.create</h2>\n<p>{% highlight java %}\nstatic <T> Observable<T> create(Observable.OnSubscribe<T> f)\n{% endhighlight %}</p>\n<p>The Observable.OnSubscribe<T> is simpler than it looks. It is basically a function that takes a Subscriber<T> for type T. Inside it we can manually determine the events that are pushed to the subscriber.</p>\n<p>{% highlight java %}\nObservable<String> values = Observable.create(subscriber -> {\nsubscriber.onNext(“Hello”);\nsubscriber.onCompleted();\n});\nSubscription subscription = values.subscribe(\nv -> System.out.println(“Received: ” + v),\ne -> System.out.println(“Error: ” + e),\n() -> System.out.println(“Completed”)\n);</p>\n<p>// Output\n// Received: Hello\n// Completed\n{% endhighlight %}</p>\n<p>When Observer subscribes to the observable (here: values), the corresponding Subscriber instance is passed to your function. As the code is executed, values are being pushed to the subscriber. Note that you have to call onCompleted in the end by yourself, if you want the sequence to signal its completion.</p>\n<p>The key difference as compared to <code class=\"language-text\">Subject</code> is that the code is executed lazily, when and if an observer subscribes. In the example above, the code is run not when the observable is created (because there is no Subscriber yet), but each time subscribe is called. This means that every value is generated again for each subscriber.</p>\n<p>This <code class=\"language-text\">Observable.create</code> is the preferred way of creating a custom observable, when none of the existing shorthands serve your purpose. The code is similar to how we created a <code class=\"language-text\">Subject</code> and pushed values to it, but there are a few important differences. First of all, the source of the events is neatly encapsulated and separated from unrelated code that means we can place the data source in Observable like this</p>\n<p>{% highlight java %}\nObservable<String> values = Observable.create(subscriber -> {\nwhile (data = getDataFromTwitter()) {\nsubscriber.onNext(data);\n}\n});\nObservable.onNext() // there is no such method defined\n// here we are not allowed to push value to the Observables once it is created\n{% endhighlight %}</p>\n<p>But, in case of <code class=\"language-text\">subject</code> we can push the value even after creating it that could cause a serious\ndangers that are not obvious: with a <code class=\"language-text\">Subject</code> you are managing state, and anyone with access to the instance can push values into it and alter the sequence</p>\n<p>{% highlight java %}\nPublishSubject<Double> subject = PublishSubject.create();\nsubject.subscribe((v -> System.out.println(“First: ”+ v)));\nsubject.onNext(1.0); // here we can push the value even after subject is created\nsubject.subscribe((v -> System.out.println(“Second: ”+ v)));\nsubject.onNext(2.0);\n{% endhighlight %}</p>\n<h2 id=\"observablefrom\" style=\"position:relative;\"><a href=\"#observablefrom\" aria-label=\"observablefrom permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Observable.from</h2>\n<p>Much like most of the functions we’ve seen so far, you can turn any kind of input into an Rx <code class=\"language-text\">Observable</code> with <code class=\"language-text\">create</code>.</p>\n<p><code class=\"language-text\">Futures</code> are part of the Java framework and you may have used it for concurrency. Since, once task is completed  they return a single value so, we can turn them into observables.</p>\n<p>{% highlight java %}\nFutureTask<Integer> f = new FutureTask<Integer>(() -> {\nThread.sleep(2000);\nreturn 21;\n});\nnew Thread(f).start();</p>\n<p>Observable<Integer> values = Observable.from(f);</p>\n<p>Subscription subscription = values.subscribe(\nv -> System.out.println(“Received: ” + v),\ne -> System.out.println(“Error: ” + e),\n() -> System.out.println(“Completed”)\n);</p>\n<p>// Output\n// Received: 21\n// Completed\n{% endhighlight %}</p>\n<p>The observable emits the result of the FutureTask when it is available and then terminates. If the task is canceled, the observable will emit a <code class=\"language-text\">java.util.concurrent.CancellationException</code> error.</p>\n<p>If you’re interested in the results of the Future for a limited amount of time, you can provide a timeout period like this</p>\n<p>{% highlight java %}\nObservable<Integer> values = Observable.from(f, 1000, TimeUnit.MILLISECONDS);\n{% endhighlight %}</p>\n<p>If the <code class=\"language-text\">Future</code> has not completed in the specified amount of time, the observable will ignore it and fail with a <strong>TimeoutException</strong>.</p>\n<p>You can also turn any collection into an observable using the overloads of <code class=\"language-text\">Observable.from</code> that take <code class=\"language-text\">arrays</code> and <code class=\"language-text\">iterables</code>. This will result in every item in the collection being emitted and then a final <code class=\"language-text\">onCompleted</code> event.</p>\n<p>{% highlight java %}\nInteger[] is = {1,2,3};\nObservable<Integer> values = Observable.from(is);\nSubscription subscription = values.subscribe(\nv -> System.out.println(“Received: ” + v),\ne -> System.out.println(“Error: ” + e),\n() -> System.out.println(“Completed”)\n);</p>\n<p>// Output\n// Received: 1\n// Received: 2\n// Received: 3\n// Completed\n{% endhighlight %}</p>\n<p>Also, not that <code class=\"language-text\">Observable</code> is not <strong><em>interchangeable</em></strong> with <code class=\"language-text\">Iterable</code> or <code class=\"language-text\">Stream</code> as <code class=\"language-text\">Observables</code> are <strong>push-based</strong> that means they push the value(once it is available) to all of its subscriber whereas, other <code class=\"language-text\">Streams</code> are <strong>pull-based</strong>, which means that values are requested as soon as possible and execution blocks until the result is returned.</p>\n<p>{% highlight java %}\nMap&#x3C;String, Integer> items = new HashMap&#x3C;>();\nitems.put(“A”, 10);\nitems.put(“B”, 20);\nitems.put(“C”, 30);</p>\n<p>items.forEach((k,v)->{\nSystem.out.println(“Item : ” + k + ” Count : ” + v);\n// pulling the values, which are available in items\n});</p>\n<p>{% endhighlight %}</p>\n<h2 id=\"functional-constructs\" style=\"position:relative;\"><a href=\"#functional-constructs\" aria-label=\"functional constructs permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Functional Constructs</h2>\n<p>In functional programming it is common to create sequences oF infinite length. RxJava has factory methods that create such observable sequences</p>\n<h3 id=\"observablerange\" style=\"position:relative;\"><a href=\"#observablerange\" aria-label=\"observablerange permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Observable.range</h3>\n<p>A straight forward and familiar method to any functional programmer. It emits the specified range of integers.</p>\n<p>{% highlight java %}\nObservable<Integer> values = Observable.range(10, 15);\n// The example emits the values from 10 to 24 in sequence.</p>\n<p>// Output\n// Received for one: 10\n// Received for one: 11\n// Received for one: 12\n// Received for one: 13\n// …\n// …\n// Received for one: 25\n{% endhighlight %}</p>\n<h3 id=\"observableinterval\" style=\"position:relative;\"><a href=\"#observableinterval\" aria-label=\"observableinterval permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Observable.interval</h3>\n<p>This function will create an infinite sequence of ticks, separated by the specified time duration.</p>\n<p>{% highlight java %}\nObservable<Long> values = Observable.interval(1000, TimeUnit.MILLISECONDS);\nSubscription subscription = values.subscribe(\nv -> System.out.println(“Received: ” + v),\ne -> System.out.println(“Error: ” + e),\n() -> System.out.println(“Completed”)\n);\nSystem.in.read();</p>\n<p>// Output\n// Received: 0\n// Received: 1\n// Received: 2\n// Received: 3\n// …\n// …\n{% endhighlight %}</p>\n<p>This sequence will not terminate until we unsubscribe.</p>\n<p>Please note the blocking read <code class=\"language-text\">System.in.read()</code> at the end is necessary here. Without it, the program terminates without printing something. That’s because the timer that produces the ticks runs on its own thread and our operations are non-blocking. We create an observable that will emit values over time, then we register the subscriber which processes the value when it arrives. None of that is blocking and the main thread proceeds to terminate so, just to block the main thread and to see the values coming from an <code class=\"language-text\">Observable</code> we used blocking read at the end.</p>\n<p>In the next post, we will unfold the Hot and Cold Observable</p>","fields":{"slug":"/posts/verbs-who","tagSlugs":["/tag/design/","/tag/typography/","/tag/web-development/"]},"frontmatter":{"date":"2017-04-03T22:40:32.169Z","description":"An Essay on Typography by Eric Gill takes the reader back to the year 1930. The year when a conflict between two worlds came to its term. The machines of the industrial world finally took over the handicrafts.","tags":["Design","Typography","Web Development"],"title":"The Verbs who rule the City of Nouns","socialImage":"/media/42-line-bible.jpg"}}},"pageContext":{"slug":"/posts/verbs-who"}}}