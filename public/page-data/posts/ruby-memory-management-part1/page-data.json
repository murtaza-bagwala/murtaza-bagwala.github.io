{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/ruby-memory-management-part1","result":{"data":{"markdownRemark":{"id":"89df99bd-08fd-5691-a76c-a16f3cbb58b0","html":"<p>In this two-part series, we aim to demystify the concepts behind Ruby’s memory management\nand take a deeper look at how\n<a href=\"https://bugs.ruby-lang.org/issues/18045\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Variable Width Allocation</a>\ncan improve Ruby’s memory performance.</p>\n<h3 id=\"rvalue\" style=\"position:relative;\"><a href=\"#rvalue\" aria-label=\"rvalue permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>RVALUE</h3>\n<p>For Dynamic Memory allocation,\nthe Ruby program uses Heap memory\nand the basic unit of the heap is a slot. Here, each slot occupies a value which is known as <strong>RVALUE</strong>.\nThis <strong>RVALUE</strong> comprises 40 bytes and a container for objects of all types (Array, String, Class).\nOut of these 40 bytes, the initial 8 bytes are reserved for a flag, followed by 8 bytes of Klass pointer.\nThe remaining 24 bytes are reserved for object-specific fields.<br>\nFor example, for a Class object, it stores the pointer to an extension object\nand for a String, it stores its content. </p>\n<p><img src=\"/ruby-memory/r-value.jpg\" alt=\"alt\"></p>\n<h3 id=\"heap-pages-\" style=\"position:relative;\"><a href=\"#heap-pages-\" aria-label=\"heap pages  permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Heap Pages:-</h3>\n<p>These 40-byte slots are organized into Heap pages.\nHeap pages are containers of 16kb memory region,\naccordingly, each Heap page has 408-409 slots\nand all the slots on the same heap page are contiguous, with no gaps in between.</p>\n<p><img src=\"/ruby-memory/heap-page.png\" alt=\"alt\"></p>\n<h3 id=\"freelist-\" style=\"position:relative;\"><a href=\"#freelist-\" aria-label=\"freelist  permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Freelist:-</h3>\n<p>Initially, when the Heap page is created, all the slots are filled with the special RVALUE type <strong>T_NONE</strong>.\nThis represents an empty slot\nand contains only a flag,\nand a Klass pointer value known as <strong>next</strong>. This can be further pointed to another RVALUE.</p>\n<p><img src=\"/ruby-memory/freelist1.png\" alt=\"alt\"></p>\n<p>Also, when the Heap page is initialized,\nRuby sets a pointer called <strong>freelist</strong> pointer to the address of the first slot,\nand then it starts visiting each of these slots.\nAs it gradually gets to each slot,\nit sets the freelist pointer to the address of the current slot\nand the current slot’s <strong>next</strong> pointer to the address of the previous slot.<br>\nIt derives the address of the previous slot from its last visit by creating a LinkedList of the empty slots called <strong>FreeList</strong>.</p>\n<p><img src=\"/ruby-memory/freelist.gif\" alt=\"alt\"></p>\n<h3 id=\"allocating-an-object\" style=\"position:relative;\"><a href=\"#allocating-an-object\" aria-label=\"allocating an object permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Allocating an object</h3>\n<p>So, when it needs to allocate an object, Ruby asks for an address of an empty slot from a Heap page.\nNot to mention, the Heap page always returns a freelist pointer that has an address to the empty slot,\nupdates a freelist pointer with the address of the next empty slot\nand also unlinks the current empty slot from the freelist.\nThis allows Ruby to put data into it.\nThe use of freelist keeps the object allocation operation constant in time,\nso each time Ruby asks for an empty slot,\nthe Heap page just checks a value of the freelist pointer\nand returns the address to Ruby.  </p>\n<p><img src=\"/ruby-memory/alloc1.png\" alt=\"alt\"></p>\n<p>Allocating an object of type Rclass</p>\n<p><img src=\"/ruby-memory/alloc2.png\" alt=\"alt\"></p>\n<p>Allocating an object of type RString</p>\n<p><img src=\"/ruby-memory/alloc3.png\" alt=\"alt\"></p>\n<p>Allocating an object of type RArray</p>\n<p><img src=\"/ruby-memory/alloc4.png\" alt=\"alt\"></p>\n<p>And once all the slots are filled in,\n<strong>Garbage Collector</strong> comes into action to reclaim spaces from the dead objects.</p>\n<h3 id=\"garbage-collection\" style=\"position:relative;\"><a href=\"#garbage-collection\" aria-label=\"garbage collection permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Garbage collection</h3>\n<p>Ruby uses the <strong>Mark-Sweep-Compact</strong> garbage collection algorithm,\nalso when GC is active, the ruby code does not get executed.\nLet us look into each of the GC phases:-</p>\n<p><strong>Marking</strong>:- It is the phase where we determine which objects are alive\nand which can be freed.\nFirst, we mark the root-like global variables,\nclasses, etc. along with their children\nuntil the mark stack is empty.</p>\n<p>Let us consider that we have 2 Heap pages with 4 slots each from A to C and E to G.\nEmpty slots are free slots\nand black slots are marked slots.\nHere, the arrow shows the references,\nfor example, an arrow from A to G shows that object A\nhas an instance variable declared in G.</p>\n<p><img src=\"/ruby-memory/mark1.png\" alt=\"alt\"></p>\n<p>Let us start with the root elements we have - A\nand B\nand push them both on the Mark stack.\nNow, let’s pop one element from the stack, mark it\nand push its children on the stack.\nHere pop A,\nand push A’s child G to mark stack.\nNow, pop B, mark it\nand push its child E in the mark stack\nand repeat this until we have the entire Mark stack as empty.\nAnd, once it has marked all the objects along with their children,\nit moves to the sweep phase.</p>\n<p><img src=\"/ruby-memory/mark.gif\" alt=\"alt\"></p>\n<p><strong>Sweeping</strong>:- It is the phase where all the unmarked objects can be reclaimed by the garbage collector.\nSo, after the marking step, this is how our heap pages look like:-</p>\n<p><img src=\"/ruby-memory/sweep1.png\" alt=\"alt\"></p>\n<p>Now, GC scans all the heap pages, checks for unmarked objects,\nand frees the space.\nIn our case, we have C\nand F as unmarked, therefore, GC will reclaim these spaces.</p>\n<p><img src=\"/ruby-memory/sweep2.png\" alt=\"alt\"></p>\n<p><strong>Compaction</strong>:- Compaction moves objects within the heap page to the start of the heap page\nand it results in various benefits including reduced memory usage, faster garbage collection,\nand better write performance.\nAlso, this involves 2 steps:-</p>\n<ul>\n<li><strong>Compact step</strong>:- This uses two cursors,\n<strong>Free cursor</strong> which moves forward\nand <strong>Compact cursor</strong> which moves backward.\nThis is why it is also called <strong>2 Fingers algorithm</strong>\nand when these two cursors meet, this step is complete. </li>\n</ul>\n<p>Let us understand this through an example.\nHere, the white arrow is the Free cursor\nand the black arrow is the Compact cursor.\nThe Free cursor begins from the start of the heap\nand moves to the first free slot.\nThen the Compact cursor starts from the end of the heap\nand moves to the first filled slot.\nIt will then move the object at the compact cursor to the free slot\nand leave a forwarding address at the original object to remember where this object was moved.\nNow, continue moving the Free cursor forward\nand the Compact cursor backward, repeat the above steps till these two cursors meet,\nmeaning that this step is complete.\nAfter this step, we can see all the initial free slots are filled.</p>\n<p><img src=\"/ruby-memory/compact.gif\" alt=\"alt\"></p>\n<ul>\n<li><strong>Update reference step</strong>:- In this step,\nwe update the pointers to objects which were moved in the compaction step.\nLet us continue with the previous example:-</li>\n</ul>\n<p><img src=\"/ruby-memory/refer1.png\" alt=\"alt\"></p>\n<p>We will now have just one cursor which will scan the objects linearly\nand check if any of the objects have the reference to a forwarding address,\nSo, in our case object, <code class=\"language-text\">A</code> and <code class=\"language-text\">B</code> have the references to forwarding addresses\nthat says <code class=\"language-text\">Moved to Heap Page 1</code>\nand it will update the reference to the correct object which is <code class=\"language-text\">G</code> and <code class=\"language-text\">E</code>.</p>\n<p><img src=\"/ruby-memory/refer2.png\" alt=\"alt\"></p>\n<p>In this blog, we looked at how Ruby manages memory\nand Garbage collection works,\nin the next blog, we will see how Variable Width Allocation works.</p>","fields":{"slug":"/posts/ruby-memory-management-part1","tagSlugs":["/tag/ruby/","/tag/ruby-3/"]},"frontmatter":{"date":"2022-04-13T18:00:37.121Z","description":"Each programming language has its version of memory management so, let us look into how Ruby does this under the hood.","tags":["ruby","ruby-3"],"title":"How does Ruby manage memory?","socialImage":null}}},"pageContext":{"slug":"/posts/ruby-memory-management-part1"}}}