{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/ruby-memory-management-part2/","result":{"data":{"markdownRemark":{"id":"93e2a832-ac22-5813-a0c8-7969f2038e6c","html":"<p>This post is in continuation of <a href=\"https://murtazabagwala.xyz/posts/ruby-memory-management-part1\">part 1</a>\nand in this blog, we will take a deeper look at how\n<a href=\"https://bugs.ruby-lang.org/issues/18045\">Variable Width Allocation</a> works\nand how it\ncan improve Ruby's memory performance.\nBefore getting into the <strong>VWA</strong> let us understand how large objects get allocated on Heap.</p>\n<h3>Large objects on the Heap</h3>\n<p>As we know the size of the slot is 40 bytes,\nin which only 24 bytes are used for storing content.\nThe rest of the 16 bytes are used for storing the flag\nand the pointer to other RVALUE.\nNow let us look at the example in which we need to allocate a string of 12 bytes\nand 37 bytes-</p>\n<p>So, in the case of 12 bytes, as it is less than 24 bytes,\nRuby stores the entire string content in the same slot.</p>\n<p><img src=\"/ruby-memory/large-object1.gif\" alt=\"alt\"></p>\n<p>And in the case of 37 bytes,\nas it is greater than 24 bytes,\nRuby makes a <code class=\"language-text\">malloc</code> call to reserve the memory space outside of a Ruby Heap\nfrom System Heap to store the content of 37 bytes String.\nNext, it stores the address of the System Heap into the slot\nand set the flag values as <code class=\"language-text\">NO_EMBED</code>\nwhich means the content is not embedded in the slot\nand it stores the pointer to content.</p>\n<p><img src=\"/ruby-memory/lballoc3.png\" alt=\"alt\"></p>\n<p>After the allocation.</p>\n<p><img src=\"/ruby-memory/iballoc6.png\" alt=\"alt\"></p>\n<h3>Bottlenecks of Ruby Heap</h3>\n<ul>\n<li>Storing content somewhere else than in the heap slot itself causes poor caching locality.</li>\n<li>While allocating large objects Ruby uses <code class=\"language-text\">malloc</code> calls which is a really expensive call and cause a performance overhead.</li>\n</ul>\n<p>Let us understand these points in detail:-</p>\n<h3>Caching</h3>\n<p>Let us understand how it causes poor caching locality. So, CPU has 3 levels of caches L1, L2,\nand L3.</p>\n<p>As L1 is on the core itself, it is faster than L2\nand L3.\nBut, this cache is very small only of 32Kb\nL2 is faster than L3\nand it has a cache size of 512Kbs\nL3 is the slowest cache\nand it has a much larger capacity of 32Mb</p>\n<p><img src=\"/ruby-memory/IBALLOC7.png\" alt=\"alt\"></p>\n<p>When data is fetched from the main memory, it is also stored in these caches.\nSo, if we continue with the above example of 37 bytes String,\nto cache it, we need to make 2 fetches-\nfirst from the main memory\nand then from main memory to system memory to fetch its content.\nThen the total size of the fetched content will be 40 (RVALUE) + 37 (Content) = 77 bytes.</p>\n<h3>Malloc</h3>\n<p>Acquiring system memory using <code class=\"language-text\">Malloc</code> is not free.\nIt comes with the performance overhead,\ntherefore, we need to minimize the number of times we are calling the <code class=\"language-text\">malloc</code>.\n<code class=\"language-text\">malloc</code> also requires space for headers that store metadata when allocating memory\nthat results in increased memory usage.</p>\n<p>Hence, to overcome the above bottlenecks,\n<strong>Variable Width Allocation</strong> was introduced.</p>\n<h3>Variable Width Allocation:-</h3>\n<p>The major goal of this project was to improve the overall performance of Ruby.\nHence, by placing the contents directly after the RVALUE, it can\nimprove the cache locality\nand by allocating dynamic size slots in a heap page,\nit can avoid expensive <code class=\"language-text\">malloc</code> system calls.</p>\n<p>Let us understand how <strong>VWA</strong> works.</p>\n<p>We know that Ruby's heap is divided into pages\nand each page is divided into a fixed size slot of 40 bytes.\nNow <strong>VWA</strong> introduced the heap pages that comprises sizes other than 40 bytes\nand to accommodate this,\na new structure is introduced called <strong>Size Pool</strong>.\nAnd, <strong>Size Pool</strong> is a collection of Heap pages with a particular slot size.\nThe slot size is a\n<a href=\"https://github.com/ruby/ruby/pull/4933/files#diff-d1cee85c3b0e24a64519c11150abe26fd0b5d8628a23d356dd0b535ac4595d49R2339\">power of 2 multiplied by the size of RVALUE</a>\nso it will be 40, 80, 160, 320, etc.</p>\n<p>So, here is a diagram of <strong>Size Pools</strong> having heap pages of different slot sizes.</p>\n<p><img src=\"/ruby-memory/size-pool.png\" alt=\"alt\"></p>\n<p>Now, when it needs to allocate the same string of 37 bytes, i.e., 40 (RVALUE) + 37 (Content) = 77 bytes.\naccording to the\n<a href=\"https://github.com/ruby/ruby/pull/4933/files#diff-d1cee85c3b0e24a64519c11150abe26fd0b5d8628a23d356dd0b535ac4595d49R2435\">source code</a>,\nit will calculate the index of the size pool using the below formula-</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">slot_count = ceil ( total_size / sizeOf(R_VALUE) ) = ceil ( 77 / 40)\nslot_count = 2\n\npool_index = ceil (log slot_count ) = ceil (log 2) = 1  // log with base 2</code></pre></div>\n<p>Next, it will go to the pool at index 1 which has a heap of pages of slot size 80\nand do the allocation.\nSo, after allocating 77 bytes on 80 bytes slot, still, 3 bytes are being wasted.\nHowever, benchmarking has shown that this has very little effect on the overall memory\nand runtime performance.</p>\n<p>So, this is how variable-width allocation works.\nCurrently, usage of <strong>VWA</strong> is only limited to Class\nand String types.\nStrings with known sizes at allocation time that are small enough are allocated as an embedded string\nand for strings with unknown sizes, or with contents that are too large,\nit falls back to allocating 40-byte slots\nand store the contents in the malloc heap.</p>\n<p>Also, if an embedded string is expanded during runtime\nand can no longer fill the slot,\nit is moved into the malloc heap.\nThis means that some space in the slot is wasted.\nFor example, if the string was originally allocated in a 160-byte slot with <strong>VWA</strong>\nand\nif it gets changed to 200 bytes during runtime,\nthen the content will be moved to the malloc heap,\nand 40 bytes will still reside in the old slot of 160 bytes. This results in 120 bytes of the slot getting wasted.</p>\n<p>We can take a look at some benchmarks results <a href=\"https://bugs.ruby-lang.org/issues/18045#Benchmark-results\">here</a>, which shows how <strong>VWA</strong> has improved Ruby's memory performance.</p>\n<p>Check out\n<a href=\"https://github.com/ruby/ruby/pull/4933\">the PR</a>\nfor more details.</p>","fields":{"slug":"/posts/ruby-memory-management-part2","tagSlugs":["/tag/ruby/","/tag/ruby-3/"]},"frontmatter":{"date":"2022-04-19T18:00:37.121Z","description":"In this blog let us understand how Variable Width Allocation works in Ruby","tags":["ruby","ruby-3"],"title":"Ruby 3.1 introduces Variable Width Allocation for Strings","socialImage":null}}},"pageContext":{"slug":"/posts/ruby-memory-management-part2"}},"staticQueryHashes":["2246977889","2727970573","984292147"],"slicesMap":{}}